// This file is autogenerated from filt_gen.py

module shared_multiplier (
    input clk,
    input reset,
    input signed [17:0] x1, x2, x3, x4,
    input signed [17:0] b1, b2, b3, b4,
    output reg signed [35:0] y1, y2, y3, y4
);
// Preforms four multiplicaton operations with a single multiplier.
// Operates at sys_clk, so new results will be available every sam_clk
// Technically this relies on having phase alignment between counter and sam_clk_ena, done with the reset
reg [1:0] counter;
always @ (posedge clk)
    if (reset)
        counter <= 2'd3;
    else
        counter <= counter + 1'b1;

reg signed [17:0] x_int, b_int;
reg signed [35:0] y_int;
always @ *
    case (counter)
        2'd0: x_int <= x1;
        2'd1: x_int <= x2;
        2'd2: x_int <= x3;
        2'd3: x_int <= x4;
    endcase
always @ *
    case (counter)
        2'd0: b_int <= b1;
        2'd1: b_int <= b2;
        2'd2: b_int <= b3;
        2'd3: b_int <= b4;
    endcase
always @ *
    y_int <= x_int * b_int;
    
reg signed [35:0] y1t, y2t, y3t;
always @ (posedge clk)
    if (reset) begin
        y1t <= 1'b0; y2t <= 1'b0; y3t <= 1'b0; y4 <= 1'b0;
    end else
        case (counter)
            2'd0: y1t <= y_int;
            2'd1: y2t <= y_int;
            2'd2: y3t <= y_int;
            2'd3: y4 <= y_int;
        endcase
// y4 is already set at the correct time. The rest need a delay to keep in sync
always @ (posedge clk)
    if (reset) begin
        y1 <= 1'b0; y2 <= 1'b0; y3 <= 1'b0;
    end else if (counter == 2'd3) begin
        y1 <= y1t; y2 <= y2t; y3 <= y3t;
    end
endmodule


module matched_filter_grm011 (
    input clk,
    input reset,
    input sam_clk_ena, // should run at 1/4 of clk frequency
    input sym_clk_ena, // should run at 1/16 of clk frequency
    input signed [17:0] x_in, // 1s17
    output reg signed [17:0] y // 1s17
);
integer i;
parameter N = 113;
parameter N_2 = 57;
wire signed [17:0] b[N_2-1:0];
reg signed [17:0] x[N-1:0];

assign b[0] = -18'sd92;
assign b[1] = -18'sd4;
assign b[2] = 18'sd95;
assign b[3] = 18'sd132;
assign b[4] = 18'sd77;
assign b[5] = -18'sd38;
assign b[6] = -18'sd131;
assign b[7] = -18'sd134;
assign b[8] = -18'sd41;
assign b[9] = 18'sd86;
assign b[10] = 18'sd153;
assign b[11] = 18'sd109;
assign b[12] = -18'sd18;
assign b[13] = -18'sd135;
assign b[14] = -18'sd151;
assign b[15] = -18'sd48;
assign b[16] = 18'sd100;
assign b[17] = 18'sd176;
assign b[18] = 18'sd110;
assign b[19] = -18'sd59;
assign b[20] = -18'sd203;
assign b[21] = -18'sd197;
assign b[22] = -18'sd18;
assign b[23] = 18'sd218;
assign b[24] = 18'sd325;
assign b[25] = 18'sd185;
assign b[26] = -18'sd144;
assign b[27] = -18'sd440;
assign b[28] = -18'sd459;
assign b[29] = -18'sd122;
assign b[30] = 18'sd395;
assign b[31] = 18'sd735;
assign b[32] = 18'sd600;
assign b[33] = -18'sd17;
assign b[34] = -18'sd766;
assign b[35] = -18'sd1123;
assign b[36] = -18'sd739;
assign b[37] = 18'sd269;
assign b[38] = 18'sd1309;
assign b[39] = 18'sd1639;
assign b[40] = 18'sd867;
assign b[41] = -18'sd701;
assign b[42] = -18'sd2129;
assign b[43] = -18'sd2372;
assign b[44] = -18'sd977;
assign b[45] = 18'sd1470;
assign b[46] = 18'sd3507;
assign b[47] = 18'sd3580;
assign b[48] = 18'sd1061;
assign b[49] = -18'sd3085;
assign b[50] = -18'sd6479;
assign b[51] = -18'sd6374;
assign b[52] = -18'sd1114;
assign b[53] = 18'sd8765;
assign b[54] = 18'sd20434;
assign b[55] = 18'sd29832;
assign b[56] = 18'sd33428;

// X Definition
always @ (posedge clk)
    if (reset)
        for (i = 0; i < N; i = i + 1)
            x[i] <= 18'b0;
    else if (sam_clk_ena) begin
        x[0] <= x_in;
        for (i = 1; i < N; i = i + 1)
            x[i] <= x[i-1];
    end

// Multiplier input definition
reg signed [17:0] mult_in[N_2-1:0];
always @ *
    for (i = 0; i < N_2; i = i + 1)
        if (i != N-i-1)
            mult_in[i] <= x[i] + x[N-i-1];
        else
            mult_in[i] <= x[i];

 //Standard multiplier output definition
 reg signed [35:0] mult_out[N_2-1:0];
 always @ (posedge clk)
     for (i = 0; i < N_2; i = i + 1)
         if (reset)
             mult_out[i] <= 36'b0;
         else if (sam_clk_ena)
             mult_out[i] <= mult_in[i] * b[i];

// Alternate multiplier definition with sharing
// Only works with N_2 % 4 = 0
//wire signed [35:0] mult_out[N_2-1:0];
//genvar g;
//generate
//    for (g = 0; g < N_2; g = g + 4)
//        shared_multiplier smult(.clk(clk), .reset(reset), .x1(mult_in[g + 0]), .x2(mult_in[g + 1]), .x3(mult_in[g + 2]), .x4(mult_in[g + 3]),
//                                                                               .b1(b[g + 0]), .b2(b[g + 1]), .b3(b[g + 2]), .b4(b[g + 3]),
//                                                                               .y1(mult_out[g + 0]), .y2(mult_out[g + 1]), .y3(mult_out[g + 2]), .y4(mult_out[g + 3]));
//endgenerate


// Adder definitions

reg signed [35:0] sum_level_0[28:0];
always @ (posedge clk) begin
    for (i = 0; i < 28; i = i + 1)
        if (reset)
            sum_level_0[i] <= 36'b0;
        else if (sam_clk_ena)
            sum_level_0[i] <= mult_out[i] + mult_out[i+28];
    if (reset)
        sum_level_0[28] <= 36'b0;
    else if (sam_clk_ena)
        sum_level_0[28] <= mult_out[56];
end

reg signed [35:0] sum_level_1[14:0];
always @ (posedge clk) begin
    for (i = 0; i < 14; i = i + 1)
        if (reset)
            sum_level_1[i] <= 36'b0;
        else if (sam_clk_ena)
            sum_level_1[i] <= sum_level_0[i] + sum_level_0[i+14];
    if (reset)
        sum_level_1[14] <= 36'b0;
    else if (sam_clk_ena)
        sum_level_1[14] <= sum_level_0[28];
end

reg signed [35:0] sum_level_2[7:0];
always @ (posedge clk) begin
    for (i = 0; i < 7; i = i + 1)
        if (reset)
            sum_level_2[i] <= 36'b0;
        else if (sam_clk_ena)
            sum_level_2[i] <= sum_level_1[i] + sum_level_1[i+7];
    if (reset)
        sum_level_2[7] <= 36'b0;
    else if (sam_clk_ena)
        sum_level_2[7] <= sum_level_1[14];
end

reg signed [35:0] sum_level_3[3:0];
always @ (posedge clk) begin
    for (i = 0; i < 4; i = i + 1)
        if (reset)
            sum_level_3[i] <= 36'b0;
        else if (sam_clk_ena)
            sum_level_3[i] <= sum_level_2[i] + sum_level_2[i+4];
end

reg signed [35:0] sum_level_4[1:0];
always @ (posedge clk) begin
    for (i = 0; i < 2; i = i + 1)
        if (reset)
            sum_level_4[i] <= 36'b0;
        else if (sam_clk_ena)
            sum_level_4[i] <= sum_level_3[i] + sum_level_3[i+2];
end

reg signed [35:0] sum_level_5[0:0];
always @ (posedge clk) begin
    for (i = 0; i < 1; i = i + 1)
        if (reset)
            sum_level_5[i] <= 36'b0;
        else if (sam_clk_ena)
            sum_level_5[i] <= sum_level_4[i] + sum_level_4[i+1];
end


always @ *
    // Slice one bit off the top here to make output 1s17
    y <= sum_level_5[0][34:17];

endmodule
